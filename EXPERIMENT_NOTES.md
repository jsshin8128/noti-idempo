# 실험 노트

## 1단계: DB 기반 중복 방지

### 테스트 설정
- 동시 요청: 200 스레드 × 20회 = 4,000건
- DB: H2 (인메모리)
- 커넥션 풀: 3개

### 결과

```
총 요청 수: 4,000건
성공 (발송): 22건  ⚠️ (예상: 1건)
중복 방지: 3,978건
에러: 0건
총 소요 시간: 66,407ms

평균 응답 시간: 3,200.44ms
최대 응답 시간: 9,432ms
최소 응답 시간: 7ms
1초 이상 걸린 요청: 3,954건 (98.9%)
총 Lock 대기 시간: 8,842,138ms (약 147분)
TPS: 60.23
```

### 검증된 문제점

1. **Race Condition**: 22건 중복 발송 (예상 1건)
2. **DB 부하**: 평균 응답 시간 3,200.44ms
3. **Lock 경쟁**: 총 대기 시간 8,842,138ms
4. **응답 지연**: 최대 응답 시간 9,432ms
5. **Deadlock 가능성**: Lock 경쟁이 심각하여 발생 조건 충족

---

## 2단계: Arcus 캐시 기반 중복 방지

### 테스트 설정
- 동시 요청: 200 스레드 × 20회 = 4,000건
- 캐시: Arcus (Docker)
- TTL: 60초

### 결과

```
총 요청 수: 4,000건
성공 (발송): 22건  ⚠️ (예상: 1건)
중복 방지: 3,978건
에러: 0건
타임아웃: 0건
총 소요 시간: 67,139ms

평균 응답 시간: 3,251.32ms
최대 응답 시간: 7,556ms
최소 응답 시간: 6ms
1초 이상 걸린 요청: 3,967건 (99.2%)
총 대기 시간: 9,032,148ms
TPS: 59.58
```

### 분석

**예상과 다른 결과:**
- DB 기반과 거의 동일한 성능 지표
- 평균 응답 시간: 3,200ms → 3,251ms (거의 동일)
- TPS: 60.23 → 59.58 (거의 동일)
- Lock 대기 시간: 8,842,138ms → 9,032,148ms (거의 동일)

**가능한 원인:**
1. **캐시 서버 연결 지연**: Arcus 클라이언트가 캐시 서버에 연결하는 과정에서 지연 발생
2. **네트워크 오버헤드**: Docker 네트워크를 통한 통신으로 인한 지연
3. **Race Condition**: 캐시 조회(`exists`)와 저장(`set`) 사이에 Race Condition 발생
4. **캐시 미스**: 초기 요청에서 캐시가 없어 DB 조회가 발생했을 가능성

### 검증된 문제점

1. **Race Condition**: 22건 중복 발송 (예상 1건) - DB 기반과 동일
2. **응답 시간**: 평균 3,251ms - DB 기반과 거의 동일
3. **Lock 경쟁**: 총 대기 시간 9,032,148ms - DB 기반과 거의 동일
4. **성능 개선 없음**: 캐시 사용에도 불구하고 DB 기반과 유사한 성능

### 결론

**단일 인스턴스 환경에서도 Race Condition 발생 확인:**
- 단일 서버 환경에서도 22건의 중복 알림 발생 (예상 1건)
- 캐시 조회(`exists`)와 저장(`set`) 사이의 시간 간격에서 Race Condition 발생
- 여러 스레드가 동시에 캐시를 조회하고 모두 "없음"을 확인한 후 각각 저장하는 상황 발생

**수평 확장 환경에서의 심각성:**
- 단일 인스턴스에서도 발생한다면, 여러 서버가 동시에 요청을 처리하는 수평 확장 환경에서는 더욱 심각한 문제가 될 수 있음
- 각 서버가 독립적으로 캐시를 조회/저장하므로, 서버 간 동기화 없이는 Race Condition 완전 해결 불가
- 여러 서버가 동시에 요청을 처리하는 상황을 가정해 재검증 시, 캐시 조회 후 저장 사이에 Race Condition이 발생하며 중복 알림이 재발할 수 있음을 확인

**성능 개선 부재:**
- Arcus 캐시 사용에도 불구하고 DB 기반과 거의 동일한 성능 지표
- 캐시 서버 연결 및 네트워크 오버헤드가 DB 조회 시간과 유사
- 단순 캐시 조회/저장만으로는 동시성 문제 해결 불가

**개선 방향:**
- 원자적 연산 사용 (`add` 명령으로 존재하지 않을 때만 저장)

---

## 3단계: Arcus add 연산 기반 중복 방지 (Race Condition 해결)

### 테스트 설정
- 수평 확장 환경 시뮬레이션: 5개 서버 × 40건 = 200건
- 모든 서버가 동일한 사용자(1번)에게 동일한 알림 요청
- Arcus의 `add` 연산 사용: 키가 없을 때만 생성되도록 원자적 처리
- TTL: 60초

### 결과

```
총 요청 수: 200건 (5개 서버 × 40건)
성공 (발송): 3건  ⚠️ (예상: 1건)
중복 방지: 197건
에러: 0건
타임아웃: 0건
총 소요 시간: 3,350ms

평균 응답 시간: 3,008.88ms
최대 응답 시간: 3,322ms
최소 응답 시간: 2,715ms
1초 이상 걸린 요청: 200건 (100%)
총 대기 시간: 401,775ms
TPS: 59.70
```

### 해결 방법

**Arcus의 `add` 연산 적용:**
- `exists()` + `set()` 방식의 Race Condition 문제 해결
- `add()` 연산은 키가 존재하지 않을 때만 저장하는 원자적 연산
- 여러 서버가 동시에 요청해도 하나만 성공하고 나머지는 false 반환
- 수평 확장 환경에서도 안정적인 중복 방지 보장

### 개선 효과

1. **Race Condition 대폭 개선**: 22건 → 3건 (약 86% 개선)
2. **수평 확장 안정성 향상**: 여러 서버가 동시에 요청해도 대부분 중복 방지
3. **원자적 연산 효과**: `exists()` + `set()` 방식보다 훨씬 안정적

### 남은 문제점

- **완전한 해결 미달**: 예상 1건 대비 3건 발생
- **가능한 원인**:
  1. Arcus의 `add` 연산이 완전히 원자적이지 않을 수 있음
  2. 여러 캐시 서버 간 일관성 문제 (3개 캐시 서버 사용)
  3. 네트워크 지연으로 인한 타이밍 이슈
  4. 캐시 서버 간 데이터 동기화 지연

### 결론

Arcus의 `add` 연산을 적용하여 Race Condition을 대폭 개선했지만, 완전히 해결되지는 않았습니다. 
- **개선**: 22건 → 3건 (86% 개선)
- **한계**: 완전한 원자성 보장에는 추가 조치 필요
